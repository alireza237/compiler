README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [cool root]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [cool root]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [cool root]/src/PA3/dumptype.cc
 handle_flags.c           -> [cool root]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [cool root]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [cool root]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [cool root]/src/PA3/tokens-lex.cc
 tree.cc		  -> [cool root]/src/PA3/tree.cc
 utilities.cc		  -> [cool root]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in
[cool root]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% make parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

در این فایل به توضیح فایل cool.y  می پردازیم
 ما باید در این فاز در انتها یک درخت خروجی بدهیم که در contex free gramer  یک سری گرامر داشتیم که در درس مبانی نظریه محاسبه ان را خواندیم و ثابت کردیم هر گرامر یک درخت دارد که در اینجا ما نیاز به درخت چپ (left derevition tree  ) داربم پس ما در این فار یک درخت می سازیم که در ان یک start sympol وجود دارد که به ان program می گوییم در واقع ما در فاز قبل برنامه ای که token token کردیم حال این را به parser ورودی می دهیم  و parser  ما ما باید یک گرامر برای زبانمان طراحی می کنیم که در واقع ما برای ساختن درخت باید برعکس عمل کنیم (از پایین) به عبارتی parsere  ما خروجی lexer  را دریافت می کند و به عبارتی تجزیه کند یعنی یک left derevition tree  بسازیم
نمودارهای درختی مبتنی بر اجزاء (= گرامر ساختار عبارت) بین گره‌های پایانه و گره‌های غیرپایانه، فرق می‌گذارد. گره‌های داخلی، طبقه غیرپایانه گرامر نامیده می‌شود در حالی که گره‌های برگ طبقه پایانه نامیده می‌شود. تصویر زیر نمودار درختی و ترکیب حوزه مبنا و ساختارنحوی جمله انگلیسی John hit the ball را نشان می‌دهد.
نمودار درختی مبتنی بر اجزاء ساختاری کامل است با S (جمله) شروع و به هریک از گروه‌های (John hit , the ,ball) ختم می‌شود. علامت‌های اختصاری زیر در نمودار درختی استفاده می‌شوند.
نخستین مرحلهٔ کامپایل تحلیل واژه‌ای (به انگلیسی: Lexical Analysis) است. به واحدی از کامپایلر که کار تحلیل واژه‌ای را انجام می‌دهد، اسکنر می‌گویند. اسکنر بین رشتهٔ ورودی و تحلیلگر نحوی (یا پارسر-parser) واقع است. وظیفهٔ اصلی اسکنر این است که با خواندن کاراکترهای ورودی، توکن‌ها را تشخیص داده و برای parser ارسال نماید. رابطهٔ scanner و parser به صورت زیر است:
به عنوان مثال در صورتی‌که رشتهٔ ورودی A:=B+C باشد، توکن‌های زیر تشخیص داده خواهند شد: (آدرسid,C) و (add .op.) و (آدرسid, B) و (ass .op.) و (آدرس id, A) بنابراین اسکنر علاوه بر اینکه تشخیص می‌دهد که توکن یک شناسه‌است، آدرس آن در جدول نشانه‌ها را نیز برای پارسر می‌فرستد. علاوه بر این اسکنر می‌تواند محل‌های خالی و توضیحات(comments) موجود در برنامه اصلی را ضمن خواندن برنامه حذف نماید. به آخرین توکنی که اسکنر یافته‌است، علامت پیش‌بینی(look ahead symbol) یا توکن جاری گفته می‌شود.
۲–۱- الگو (pattern) و واژهٔ(Lexem) توکنها: به فرم کلی که یک توکن می‌تواند داشته باشد، الگوی آن توکن می‌گویند. به عبارتی دیگر در ورودی، رشته‌هایی وجود دارند که توکنِ یکسانی برای آن‌ها تشخیص داده می‌شود. فرم کلی این رشته‌ها توسط الگوی آن توکن توصیف می‌شود. به دنباله‌ای از نویسه‌ها که تشکیل یک توکن می‌دهند، واژه(Lexem) آن توکن می‌گویند. جدول زیر حاوی چند نمونه الگو و واژه‌است:
الگو واژه توکن با حروف الفبا شروع و به‌دنبال آن حرف ورقم قرار می‌گیرد A1 id هرثابت عددی ۳٫۱۴ num
هر رشتهٔ کاراکتری که بین دو علامت " " قرار گیرد "book" literal
<<relation >=>= relation if if if
در بعضی وضعیتها اسکنر قبل از اینکه تصمیم بگیرد که چه توکنی را به پارسر بفرستد، نیاز دارد که چند کاراکتر دیگر را نیز، از ورودی بخواند. مثلاً اسکنر با دیدن علامت <در ورودی نیاز دارد که کاراکتر ورودی بعدی را نیز بخواند. در صورتی‌که این کاراکتر = باشد، در نتیجه توکن '<=' و در غیر اینصورت توکن ' <' تشخیص داده می‌شود. در این مورد باید کاراکتر اضافی خوانده شده مجدداً به ورودی برگردد.
یکی دیگر از مشکلاتی که اسکنر با آن روبروست این است که در زبان‌هایی نظیر فرترن مثلاً محل خالی یا (space) بجز در رشته‌های کاراکتری، نادیده گرفته می‌شود. به عنوان مثال کلمهٔ Do در زبان فرترن را در دستور زیر در نظر بگیرید: do bi =۱٫۲۵ تا زمانی‌که به نقطهٔ اعشار در ۱٫۲۵ نرسیده باشیم نمی‌توان گفت که do در این دستور کلمه کلیدی نیست، بلکه بخشی از متغیری است که نام آن do bi است. به همین ترتیب در دستور do bi=۱٬۲۵ تا زمانی‌که علامت کاما دیده نشود، نمی‌توان گفت که این دستور یک حلقهٔ do است.
در زبان‌هایی که کلمات کلیدی آن جزو کلمات رزرو شده نیستند، اسکنر نمی‌تواند کلمات کلیدی را از شناسه‌های همنام آن‌ها تشخیص دهد. به عنوان مثال در دستور زیر:
IF Then THEN then=else;ELSE Else=Then;
جدا کردن کلمهٔ کلیدی THEN از متغیری که نام آن Then است بسیار مشکل است. در این موارد معمولاً پارسر تشخیص نهایی را خواهد داد.
۲–۲- خطاهای واژه‌ای(Lexical Errors): به‌طور کلی خطاهای محدودی را اسکنر می‌تواند بیابد، زیرا اسکنر تمام برنامهٔ ورودی را یکجا نمی‌بیند بلکه هر بار قسمت کوچکی از برنامهٔ منبع را. به‌عنوان مثال هرگاه رشتهٔ fi در یک برنامهٔ C برای بار اول مشاهده شود، اسکنر قادر نیست تشخیص دهد که آیا fi یک املای غلط از کلمهٔ کلیدی if است یا نام یک متغیر است: fi (x==۳) از آنجایی که fi می‌تواند نام یک متغیر مجاز باشد، اسکنر این توکن را به‌عنوان یک شناسه به پارسر می‌فرستد تا اینکه پارسر در اینمورد تصمیم بگیرد. اما ممکن است خطاهایی پیش بیاید که اسکنر قادر به انجام هیچ عملی نباشد. در این مورد، برنامهٔ خطا پرداز (error handler) فرا خوانده می‌شودتاآن خطا را به نحوی برطرف کند. روش‌های مختلفی برای این کار وجود دارد که ساده‌ترین آن‌ها روشی است بنام panic mode (وضعیت هراس). در این روش آنقدر از رشتهٔ ورودی حذف می‌شود تا اینکه یک توکن درست، تشخیص داده شود. سایر روش‌های تصحیح خطا(error recovery) عبارت‌اند از: a) حذف یک کاراکتر غیرمجاز (تبدیل:$= به :=) b) وارد کردن یک کاراکتر گم شده (مثلاً تبدیل: به :=) c) تعویض کردن یک کاراکتر غلط با یک کاراکتر درست (مثلاً تبدیل :: به :=) d) جابجایی دو کاراکتر مجاز (مانند =: به :=)



در این فایل ما باید non terminal وterminal هارو بنویسم ما یک سری ترمینال ها داریم که از لکسر خود گرفته ایم (توکن) حال بابد ابتدا type گرامر های non terminal هارو مشخص بکنیم که همان طور که در فایل cool.tour میتوان مشاهده کرد ما برای اینکار نیاز به تعرف program,class_list,class,… داریم و این را در نظر بگیرید بعضی موقع گرامر های جدیدی برای تمیزی تعریف کردیم و حال باید اولویت ها را قرار بدهیم طبق cool.mnual:
11.1 Precedence
The precedence of infix binary and prefix unary operations, from highest to lowest, is given by the
following table:
.
@
~
isvoid
* /
+ -
<= < =
not
<-
All binary operations are left-associative, with the exception of

این را در نظر بگیرید که برای ذlet مامجبوریم دستور in را با کمترین اولویت قرار بدهیم

حال به توضیح گرامر ها می پردازیم طبق این جدول:
program ::= [[class; ]]+
class ::= class TYPE [inherits TYPE] { [[feature; ]]_}
feature ::= ID( [ formal [[, formal]]_ ] ) : TYPE { expr }
| ID : TYPE [ <- expr ]
formal ::= ID : TYPE
expr ::= ID <- expr
| expr[@TYPE].ID( [ expr [[, expr]]_ ] )
| ID( [ expr [[, expr]]_ ] )
| if expr then expr else expr fi
| while expr loop expr pool
| { [[expr; ]]+}
| let ID : TYPE [ <- expr ] [[, ID : TYPE [ <- expr ]]]_ in expr
| case expr of [[ID : TYPE => expr; ]]+esac
| new TYPE
| isvoid expr
| expr + expr
| expr − expr
| expr _ expr
| expr / expr
| ˜expr
| expr < expr
| expr <= expr
| expr = expr
| not expr
| (expr)
| ID
| integer
| string
| true
| false
حال واضح است که چکار باید کرد اما این را در نظر بگیرید برای گرامر هایی که به صورت [[class; ]]+ تعریف شده است باید یک گرامر جداگونه تعریف کرد که بنا بر حالت می تواند این لیست تهی باشد یا خیر
برای program  طبق جدول بالا باید لیست از کلاس ها داشته بایم
حال برای لیست کلاس ها باید دو حالت در نظر بگیریم یا این لیست (نود درخت) یک کلاس است یا لیستی از کلاس ها است باید در نظر گرفت برای وقتی که یک کلاس است از دستور single_classes استفاده کرد که این یک نود به درخت ما اضافه می کند و اگر به صورت چندتا کلاس بود باید کلاس مورد نظر را به لیستمان اضافه کنیم همچنین برای باید در نظر بگیرید اینجا برای قسمت {} باید در نظر بگیرید که درخت ما کامل شده است یعنی باید نتیجه را برگرداند همچنین این کار با این دستورات انجام شده
Classes nil_Classes();
Classes single_Classes(Class_);
Classes append_Classes(Classes,Classes);
Class_ nth(int index);
int len();
که در این تابع ها باید به تایپ ها توجه شود حال برای CLASS گرامر بنویسیم که دستورات ان از جدول بالا واضح است اما این را در نظر بگیرید که برای حالت OPTIONAL باید دو حالت در نظر بگیریم حال برای اکشن ان ها باید به دو فایل COOL TOUR , COOL.TREE.ASM توجه کرد برای مثال برای CLASS
Here is a complete use of one member:
class__class c;
Symbol p;
Symbol class__class::get_parent() { return parent; }
c = class(idtable.add_string("Foo",3),idtable.add_string("Bar"),nil_Features(),
stringtable.add_string("filename"));
p = c->get_parent(); // Sets p to the symbol for "Bar"
It will be useful in writing a Cool compiler to extend the AST with new functions such as get parent.
Simply modify the cool-tree.h _le to add functions to the class of the appropriate phylum or constructor.
البته اینجا از STRINGTABLE هم استفاده می کنیم که فاز قبل ان را توضیح دادیم
برای feature  formal  نیز مانند کلاس گرامر می نوسیم اما برای exp بعضی از انها گرمر ساده ای دارند و action ان ها نیز ساده است و با توجه به دو فیل زیذ می توان نوشت
_ program
This constructor is applied at the end of parsing to the _nal list of classes. The only needed use of
this constructor is already in the skeleton cool.y.
_ class
This constructor builds a class node from two types and a list of features. See the examples above.
_ method
This is one of the two constructors in the Feature phylum. Use this constructor to build AST
nodes for methods. Note that the second argument is a list of Formals.
_ attr
This is the constructor for attributes. The init _eld is for the expression that is the optional
initialization.
6
_ formal
This is the constructor for formal parameters in method de_nitions. The _eld names are self-
explanatory.
_ branch
This is the single constructor in the Case phylum. A branch of a case expression has the form
name : typeid => expr;
which corresponds to the _eld names in the obvious way. Use this constructor to build an AST for
each branch of a case expression.
_ assign
This is the constructor for assignment expressions.
_ static dispatch and dispatch
There are two di_erent kinds of dispatch in Cool and they have distinct constructors. See the
CoolAid for a discussion of static vs. normal dispatch. Note there is a shorthand for dispatch that
omits the self parameter. Don't use the no expr constructor in place of self; you need to _ll in
the symbol for self for the rest of the compiler to work correctly.
_ cond
This is the constructor for if-then-else expressions.
_ loop
This is the constructor for loop-pool expressions.
_ typcase
This constructor builds an AST for a case expression. Note that the second argument is a list of
case branches (see the branch constructor above).
_ block
This is the constructor for f...g block expressions.
_ let
This is the constructor for let expressions. Note that the let constructor only allows one identi_er.
When parsing a let expression with multiple identi_ers, it should be transformed into nested lets
with single identi_ers, as described in the semantics for let in the CoolAid.
_ plus
This is the constructor for + expressions.
_ sub
This is the constructor for 􀀀 expressions.
_ mul
This is the constructor for _ expressions.
_ divide
This is the constructor for = expressions.
7
_ neg
This is the constructor for ~ expressions.
_ lt
This is the constructor for < expressions.
_ eq
This is the constructor for = expressions.
_ leq
This is the constructor for <= expressions.
_
اما بعضی ان ها از جمله let ,… فرق می کند باید این را در نظر بگیرید که در بعضی از گرامر ها که بهصورت مثلا exp_list تعریف می کنیم علامت های بین ان مهم است یعنی بعضی موقع ها باید بینشان , باشد و در بعضی موقع ها هیجی و همین طور بعضی موقع ها ; باید در انتها باشد و در بعضی موقع ها خیر اما حال به let را گرامش را می نوسیم همان طور که در گرامر ان می بینیم let را می توان به صورت بازگشتی نوشت به عبارتی ان فایل optional در خود تعریف let  هست به عبارتی اگر let اول را کنار بگذاریم داریم   ID : TYPE [ <- expr ] [[, ID : TYPE [ <- expr ]]]_ in expr می بینیم که
[[, ID : TYPE [ <- expr ] که تکرار میشود پس ما let را مانند لیست تعریف می کنیم :


let_expr
: OBJECTID ':' TYPEID IN expr
    	                      { $$ = let($1, $3, no_expr(), $5); }
    | OBJECTID ':' TYPEID ',' let_expr
    	                       { $$ = let($1, $3, no_expr(), $5); }
    | OBJECTID ':' TYPEID ASSIGN expr IN expr
    		                 { $$ = let($1, $3, $5, $7); }
    | OBJECTID ':' TYPEID ASSIGN expr ',' let_expr
                       { $$ = let($1, $3, $5, $7); }



برای بقیه گرامر ها و action ها واضح است که چیکار کردیم
اما برای error ها ما همان 4 error که در صورت فاز پروژه امده است پیاده سازی کردیم به این صورت برای class,feature واضح است زیرا که برای هر کلاس اگر با eror بخوریم و در اخر ; ببینیم کلا صرف نظر می کنیم و به کلاس بعدی می رویم البته این خیلی کلی است و می توان برای مثال  feature حالت بندی بکنیم برای مثال:

| OBJECTID ':' error ';'
| OBJECTID '(' formal formal_list ')' ':' TYPEID '{' error '}' ';'
| OBJECTID '(' ')' ':' TYPEID '{' error '}' ';'
| OBJECTID '(' error ')' ':' TYPEID '{' expr'}' ';'
| OBJECTID '(' error formal_list ')' ':' TYPEID '{' expr '}' ';'


و حال برای ارور block  نیز باید در نظر گرفت که در هر block لیستس از expr است و اگر یکی از انها به eror خورد نباید کامپایلر هالت کند یعنی به صورت زیر بنویسیم:
برای let  نیز این گونه است و action block نیز برای همه واضح و برابر  $$=NULL;      است



Good.cl:
#1
_program
  #1
  _class
    A
    Object
    "good.cl"
    (
    #2
    _method
      ana
      Int
      #3
      _plus
        #3
        _let
          x
          Int
          #3
          _int
            1
          : _no_type
          #3
          _int
            2
          : _no_type
        : _no_type
        #3
        _int
          3
        : _no_type
      : _no_type
    )
  #7
  _class
    BB__
    A
    "good.cl"
    (




Bad.cl:
"bad.cl", line 15: syntax error at or near OBJECTID = b
"bad.cl", line 19: syntax error at or near OBJECTID = a
"bad.cl", line 23: syntax error at or near OBJECTID = inherts
"bad.cl", line 28: syntax error at or near ';'
Good1.cl:
(*
 *  A contribution from Anne Sheets (sheets@cory)
 *
 *  Tests the arithmetic operations and various other things
 *)

class A {

   var : Int <- 0;

   value() : Int { var };

   set_var(num : Int) : SELF_TYPE {
      {
         var <- num;
         self;
      }
   };

   method1(num : Int) : SELF_TYPE {  -- same
      self
   };

   method2(num1 : Int, num2 : Int) : B {  -- plus
      (let x : Int in
         {
            x <- num1 + num2;
            (new B).set_var(x);
         }
      )
   };

   method3(num : Int) : C {  -- negate
      (let x : Int in
         {
            x <- ~num;
            (new C).set_var(x);
         }
      )
   };

   method4(num1 : Int, num2 : Int) : D {  -- diff
            if num2 < num1 then
               (let x : Int in
                  {
                     x <- num1 - num2;
                     (new D).set_var(x);
                  }
               )
            else
               (let x : Int in
                  {
                     x <- num2 - num1;
                     (new D).set_var(x);
                  }
               )
            fi
   };

   method5(num : Int) : E {  -- factorial
      (let x : Int <- 1 in
         {
            (let y : Int <- 1 in
               while y <= num loop
                  {
                     x <- x * y;
                     y <- y + 1;
                  }
               pool
            );
            (new E).set_var(x);
         }
      )
   };

};

class B inherits A {  -- B is a number squared

   method5(num : Int) : E { -- square
      (let x : Int in
         {
            x <- num * num;
            (new E).set_var(x);
         }
      )
   };

};

class C inherits B {

   method6(num : Int) : A { -- negate
      (let x : Int in
         {
            x <- ~num;
            (new A).set_var(x);
         }
      )
   };

   method5(num : Int) : E {  -- cube
      (let x : Int in
         {
            x <- num * num * num;
            (new E).set_var(x);
         }
      )
   };

};

class D inherits B {

   method7(num : Int) : Bool {  -- divisible by 3
      (let x : Int <- num in
            if x < 0 then method7(~x) else
            if 0 = x then true else
            if 1 = x then false else
            if 2 = x then false else
               method7(x - 3)
            fi fi fi fi
      )
   };

};

class E inherits D {

   method6(num : Int) : A {  -- division
      (let x : Int in
         {
            x <- num / 8;
            (new A).set_var(x);
         }
      )
   };

};

(* The following code is from atoi.cl in ~cs164/examples *)

(*
   The class A2I provides integer-to-string and string-to-integer
conversion routines.  To use these routines, either inherit them
in the class where needed, have a dummy variable bound to
something of type A2I, or simpl write (new A2I).method(argument).
*)


(*
   c2i   Converts a 1-character string to an integer.  Aborts
         if the string is not "0" through "9"
*)
class A2I {

     c2i(char : String) : Int {
        if char = "0" then 0 else
        if char = "1" then 1 else
        if char = "2" then 2 else
        if char = "3" then 3 else
        if char = "4" then 4 else
        if char = "5" then 5 else
        if char = "6" then 6 else
        if char = "7" then 7 else
        if char = "8" then 8 else
        if char = "9" then 9 else
        { abort(); 0; }  (* the 0 is needed to satisfy the
                                  typchecker *)
        fi fi fi fi fi fi fi fi fi fi
     };

(*
   i2c is the inverse of c2i.
*)
     i2c(i : Int) : String {
        if i = 0 then "0" else
        if i = 1 then "1" else
        if i = 2 then "2" else
        if i = 3 then "3" else
        if i = 4 then "4" else
        if i = 5 then "5" else
        if i = 6 then "6" else
        if i = 7 then "7" else
        if i = 8 then "8" else
        if i = 9 then "9" else
        { abort(); ""; }  -- the "" is needed to satisfy the typchecker
        fi fi fi fi fi fi fi fi fi fi
     };

(*
   a2i converts an ASCII string into an integer.  The empty string
is converted to 0.  Signed and unsigned strings are handled.  The
method aborts if the string does not represent an integer.  Very
long strings of digits produce strange answers because of arithmetic
overflow.

*)
     a2i(s : String) : Int {
        if s.length() = 0 then 0 else
        if s.substr(0,1) = "-" then ~a2i_aux(s.substr(1,s.length()-1)) else
        if s.substr(0,1) = "+" then a2i_aux(s.substr(1,s.length()-1)) else
           a2i_aux(s)
        fi fi fi
     };

(* a2i_aux converts the usigned portion of the string.  As a
   programming example, this method is written iteratively.  *)


     a2i_aux(s : String) : Int {
        (let int : Int <- 0 in
           {
               (let j : Int <- s.length() in
                  (let i : Int <- 0 in
                    while i < j loop
                        {
                            int <- int * 10 + c2i(s.substr(i,1));
                            i <- i + 1;
                        }
                    pool
                  )
               );
              int;
            }
        )
     };

(* i2a converts an integer to a string.  Positive and negative
   numbers are handled correctly.  *)

    i2a(i : Int) : String {
        if i = 0 then "0" else
        if 0 < i then i2a_aux(i) else
          "-".concat(i2a_aux(i * ~1))
        fi fi
    };

(* i2a_aux is an example using recursion.  *)

    i2a_aux(i : Int) : String {
        if i = 0 then "" else
            (let next : Int <- i / 10 in
                i2a_aux(next).concat(i2c(i - next * 10))
            )
        fi
    };

};

class Main inherits IO {

   char : String;
   avar : A;
   a_var : A;
   flag : Bool <- true;


   menu() : String {
      {
         out_string("\n\tTo add a number to ");
         print(avar);
         out_string("...enter a:\n");
         out_string("\tTo negate ");
         print(avar);
         out_string("...enter b:\n");
         out_string("\tTo find the difference between ");
         print(avar);
         out_string("and another number...enter c:\n");
         out_string("\tTo find the factorial of ");
         print(avar);
         out_string("...enter d:\n");
         out_string("\tTo square ");
         print(avar);
         out_string("...enter e:\n");
         out_string("\tTo cube ");
         print(avar);
         out_string("...enter f:\n");
         out_string("\tTo find out if ");
         print(avar);
         out_string("is a multiple of 3...enter g:\n");
         out_string("\tTo divide ");
         print(avar);
         out_string("by 8...enter h:\n");
         out_string("\tTo get a new number...enter j:\n");
         out_string("\tTo quit...enter q:\n\n");
         in_string();
      }
   };

   prompt() : String {
      {
         out_string("\n");
         out_string("Please enter a number...  ");
         in_string();
      }
   };

   get_int() : Int {
      {
         (let z : A2I <- new A2I in
            (let s : String <- prompt() in
               z.a2i(s)
            )
         );
      }
   };

   is_even(num : Int) : Bool {
      (let x : Int <- num in
            if x < 0 then is_even(~x) else
            if 0 = x then true else
            if 1 = x then false else
                  is_even(x - 2)
            fi fi fi
      )
   };

   class_type(var : A) : SELF_TYPE {
      case var of
         a : A => out_string("Class type is now A\n");
         b : B => out_string("Class type is now B\n");
         c : C => out_string("Class type is now C\n");
         d : D => out_string("Class type is now D\n");
         e : E => out_string("Class type is now E\n");
         o : Object => out_string("Oooops\n");
      esac
   };

   print(var : A) : SELF_TYPE {
     (let z : A2I <- new A2I in
        {
           out_string(z.i2a(var.value()));
           out_string(" ");
        }
     )
   };

   main() : Object {
      {
         avar <- (new A);
         while flag loop
            {
               -- avar <- (new A).set_var(get_int());
               out_string("number ");
               print(avar);
               if is_even(avar.value()) then
                  out_string("is even!\n")
               else
                  out_string("is odd!\n")
               fi;
               -- print(avar); -- prints out answer
               class_type(avar);
               char <- menu();
                  if char = "a" then -- add
                     {
                        a_var <- (new A).set_var(get_int());
                        avar <- (new B).method2(avar.value(), a_var.value());
                     } else
                  if char = "b" then -- negate
                     case avar of
                           c : C => avar <- c.method6(c.value());
                           a : A => avar <- a.method3(a.value());
                           o : Object => {
                                  out_string("Oooops\n");
                                  abort(); 0;
                               };
                     esac else
                  if char = "c" then -- diff
                     {
                        a_var <- (new A).set_var(get_int());
                        avar <- (new D).method4(avar.value(), a_var.value());
                     } else
                  if char = "d" then avar <- (new C)@A.method5(avar.value()) else
                          -- factorial
                  if char = "e" then avar <- (new C)@B.method5(avar.value()) else
                          -- square
                  if char = "f" then avar <- (new C)@C.method5(avar.value()) else
                          -- cube
                  if char = "g" then -- multiple of 3?
                      if ((new D).method7(avar.value()))
                                       then -- avar <- (new A).method1(avar.value())
                         {
                            out_string("number ");
                            print(avar);
                            out_string("is divisible by 3.\n");
                         }
                         else  -- avar <- (new A).set_var(0)
                         {
                            out_string("number ");
                            print(avar);
                            out_string("is not divisible by 3.\n");
                         }
                      fi else
                  if char = "h" then
                      (let x : A in
                         {
                            x <- (new E).method6(avar.value());
                            (let r : Int <- (avar.value() - (x.value() * 8)) in
                               {
                                  out_string("number ");
                                  print(avar);
                                  out_string("is equal to ");
                                  print(x);
                                  out_string("times 8 with a remainder of ");
                                  (let a : A2I <- new A2I in
                                     {
                                        out_string(a.i2a(r));
                                        out_string("\n");
                                     }
                                  ); -- end let a:
                               }
                            ); -- end let r:
                            avar <- x;
                         }
                      )  -- end let x:
                      else
                  if char = "j" then avar <- (new A)
                      else
                  if char = "q" then flag <- false
                      else
                      avar <- (new A).method1(avar.value()) -- divide/8
                  fi fi fi fi fi fi fi fi fi fi;
            }
         pool;
       }
   };

};
Output:
  #7
  _class
    A
    Object
    "good1.cl"
    (
    #9
    _attr
      var
      Int
      #9
      _int
        0
      : _no_type
    #11
    _method
      value
      Int
      #11
      _object
        var
      : _no_type
    #13
    _method
      set_var
      #13
      _formal
        num
        Int
      SELF_TYPE
      #14
      _block
        #15
        _assign
          var
          #15
          _object
            num
          : _no_type
        : _no_type
        #16
        _object
          self
        : _no_type
      : _no_type
    #20
    _method
      method1
      #20
      _formal
        num
        Int
      SELF_TYPE
      #21
      _object
        self
      : _no_type
    #24
    _method
      method2
      #24
      _formal
        num1
        Int
      #24
      _formal
        num2
        Int
      B
      #25
      _let
        x
        Int
        #25
        _no_expr
        : _no_type
        #26
        _block
          #27
          _assign
            x
            #27
            _plus
              #27
              _object
                num1
              : _no_type
              #27
              _object
                num2
              : _no_type
            : _no_type
          : _no_type
          #28
          _dispatch
            #28
            _new
              B
            : _no_type
            set_var
            (
            #28
            _object
              x
            : _no_type
            )
          : _no_type
        : _no_type
      : _no_type
    #33
    _method
      method3
      #33
      _formal
        num
        Int
      C
      #34
      _let
        x
        Int
        #34
        _no_expr
        : _no_type
        #35
        _block
          #36
          _assign
            x
            #36
            _neg
              #36
              _object
                num
              : _no_type
            : _no_type
          : _no_type
          #37
          _dispatch
            #37
            _new
              C
            : _no_type
            set_var
            (
            #37
            _object
              x
            : _no_type
            )
          : _no_type
        : _no_type
      : _no_type
    #42
    _method
      method4
      #42
      _formal
        num1
        Int
      #42
      _formal
        num2
        Int
      D
      #43
      _cond
        #43
        _lt
          #43
          _object
            num2
          : _no_type
          #43
          _object
            num1
          : _no_type
        : _no_type
        #44
        _let
          x
          Int
          #44
          _no_expr
          : _no_type
          #45
          _block
            #46
            _assign
              x
              #46
              _sub
                #46
                _object
                  num1
                : _no_type
                #46
                _object
                  num2
                : _no_type
              : _no_type
            : _no_type
            #47
            _dispatch
              #47
              _new
                D
              : _no_type
              set_var
              (
              #47
              _object
                x
              : _no_type
              )
            : _no_type
          : _no_type
        : _no_type
        #51
        _let
          x
          Int
          #51
          _no_expr
          : _no_type
          #52
          _block
            #53
            _assign
              x
              #53
              _sub
                #53
                _object
                  num2
                : _no_type
                #53
                _object
                  num1
                : _no_type
              : _no_type
            : _no_type
            #54
            _dispatch
              #54
              _new
                D
              : _no_type
              set_var
              (
              #54
              _object
                x
              : _no_type
              )
            : _no_type
          : _no_type
        : _no_type
      : _no_type
    #60
    _method
      method5
      #60
      _formal
        num
        Int
      E
      #61
      _let
        x
        Int
        #61
        _int
          1
        : _no_type
        #62
        _block
          #63
          _let
            y
            Int
            #63
            _int
              1
            : _no_type
            #64
            _loop
              #64
              _leq
                #64
                _object
                  y
                : _no_type
                #64
                _object
                  num
                : _no_type
              : _no_type
              #65
              _block
                #66
                _assign
                  x
                  #66
                  _mul
                    #66
                    _object
                      x
                    : _no_type
                    #66
                    _object
                      y
                    : _no_type
                  : _no_type
                : _no_type
                #67
                _assign
                  y
                  #67
                  _plus
                    #67
                    _object
                      y
                    : _no_type
                    #67
                    _int
                      1
                    : _no_type
                  : _no_type
                : _no_type
              : _no_type
            : _no_type
          : _no_type
          #71
          _dispatch
            #71
            _new
              E
            : _no_type
            set_var
            (
            #71
            _object
              x
            : _no_type
            )
          : _no_type
        : _no_type
      : _no_type
    )
  #78
  _class
    B
    A
    "good1.cl"
    (
    #80
    _method
      method5
      #80
      _formal
        num
        Int
      E
      #81
      _let
        x
        Int
        #81
        _no_expr
        : _no_type
        #82
        _block
          #83
          _assign
            x
            #83
            _mul
              #83
              _object
                num
              : _no_type
              #83
              _object
                num
              : _no_type
            : _no_type
          : _no_type
          #84
          _dispatch
            #84
            _new
              E
            : _no_type
            set_var
            (
            #84
            _object
              x
            : _no_type
            )
          : _no_type
        : _no_type
      : _no_type
    )
  #91
  _class
    C
    B
    "good1.cl"
    (
    #93
    _method
      method6
      #93
      _formal
        num
        Int
      A
      #94
      _let
        x
        Int
        #94
        _no_expr
        : _no_type
        #95
        _block
          #96
          _assign
            x
            #96
            _neg
              #96
              _object
                num
              : _no_type
            : _no_type
          : _no_type
          #97
          _dispatch
            #97
            _new
              A
            : _no_type
            set_var
            (
            #97
            _object
              x
            : _no_type
            )
          : _no_type
        : _no_type
      : _no_type
    #102
    _method
      method5
      #102
      _formal
        num
        Int
      E
      #103
      _let
        x
        Int
        #103
        _no_expr
        : _no_type
        #104
        _block
          #105
          _assign
            x
            #105
            _mul
              #105
              _mul
                #105
                _object
                  num
                : _no_type
                #105
                _object
                  num
                : _no_type
              : _no_type
              #105
              _object
                num
              : _no_type
            : _no_type
          : _no_type
          #106
          _dispatch
            #106
            _new
              E
            : _no_type
            set_var
            (
            #106
            _object
              x
            : _no_type
            )
          : _no_type
        : _no_type
      : _no_type
    )
  #113
  _class
    D
    B
    "good1.cl"
    (
    #115
    _method
      method7
      #115
      _formal
        num
        Int
      Bool
      #116
      _let
        x
        Int
        #116
        _object
          num
        : _no_type
        #117
        _cond
          #117
          _lt
            #117
            _object
              x
            : _no_type
            #117
            _int
              0
            : _no_type
          : _no_type
          #117
          _dispatch
            #117
            _object
              self
            : _no_type
            method7
            (
            #117
            _neg
              #117
              _object
                x
              : _no_type
            : _no_type
            )
          : _no_type
          #118
          _cond
            #118
            _eq
              #118
              _int
                0
              : _no_type
              #118
              _object
                x
              : _no_type
            : _no_type
            #118
            _bool
              1
            : _no_type
            #119
            _cond
              #119
              _eq
                #119
                _int
                  1
                : _no_type
                #119
                _object
                  x
                : _no_type
              : _no_type
              #119
              _bool
                0
              : _no_type
              #120
              _cond
                #120
                _eq
                  #120
                  _int
                    2
                  : _no_type
                  #120
                  _object
                    x
                  : _no_type
                : _no_type
                #120
                _bool
                  0
                : _no_type
                #121
                _dispatch
                  #121
                  _object
                    self
                  : _no_type
                  method7
                  (
                  #121
                  _sub
                    #121
                    _object
                      x
                    : _no_type
                    #121
                    _int
                      3
                    : _no_type
                  : _no_type
                  )
                : _no_type
              : _no_type
            : _no_type
          : _no_type
        : _no_type
      : _no_type
    )
  #128
  _class
    E
    D
    "good1.cl"
    (
    #130
    _method
      method6
      #130
      _formal
        num
        Int
      A
      #131
      _let
        x
        Int
        #131
        _no_expr
        : _no_type
        #132
        _block
          #133
          _assign
            x
            #133
            _divide
              #133
              _object
                num
              : _no_type
              #133
              _int
                8
              : _no_type
            : _no_type
          : _no_type
          #134
          _dispatch
            #134
            _new
              A
            : _no_type
            set_var
            (
            #134
            _object
              x
            : _no_type
            )
          : _no_type
        : _no_type
      : _no_type
    )
  #155
  _class
    A2I
    Object
    "good1.cl"
    (
    #157
    _method
      c2i
      #157
      _formal
        char
        String
      Int
      #158
      _cond
        #158
        _eq
          #158
          _object
            char
          : _no_type
          #158
          _string
            "0"
          : _no_type
        : _no_type
        #158
        _int
          0
        : _no_type
        #159
        _cond
          #159
          _eq
            #159
            _object
              char
            : _no_type
            #159
            _string
              "1"
            : _no_type
          : _no_type
          #159
          _int
            1
          : _no_type
          #160
          _cond
            #160
            _eq
              #160
              _object
                char
              : _no_type
              #160
              _string
                "2"
              : _no_type
            : _no_type
            #160
            _int
              2
            : _no_type
            #161
            _cond
              #161
              _eq
                #161
                _object
                  char
                : _no_type
                #161
                _string
                  "3"
                : _no_type
              : _no_type
              #161
              _int
                3
              : _no_type
              #162
              _cond
                #162
                _eq
                  #162
                  _object
                    char
                  : _no_type
                  #162
                  _string
                    "4"
                  : _no_type
                : _no_type
                #162
                _int
                  4
                : _no_type
                #163
                _cond
                  #163
                  _eq
                    #163
                    _object
                      char
                    : _no_type
                    #163
                    _string
                      "5"
                    : _no_type
                  : _no_type
                  #163
                  _int
                    5
                  : _no_type
                  #164
                  _cond
                    #164
                    _eq
                      #164
                      _object
                        char
                      : _no_type
                      #164
                      _string
                        "6"
                      : _no_type
                    : _no_type
                    #164
                    _int
                      6
                    : _no_type
                    #165
                    _cond
                      #165
                      _eq
                        #165
                        _object
                          char
                        : _no_type
                        #165
                        _string
                          "7"
                        : _no_type
                      : _no_type
                      #165
                      _int
                        7
                      : _no_type
                      #166
                      _cond
                        #166
                        _eq
                          #166
                          _object
                            char
                          : _no_type
                          #166
                          _string
                            "8"
                          : _no_type
                        : _no_type
                        #166
                        _int
                          8
                        : _no_type
                        #167
                        _cond
                          #167
                          _eq
                            #167
                            _object
                              char
                            : _no_type
                            #167
                            _string
                              "9"
                            : _no_type
                          : _no_type
                          #167
                          _int
                            9
                          : _no_type
                          #168
                          _block
                            #168
                            _dispatch
                              #168
                              _object
                                self
                              : _no_type
                              abort
                              (
                              )
                            : _no_type
                            #168
                            _int
                              0
                            : _no_type
                          : _no_type
                        : _no_type
                      : _no_type
                    : _no_type
                  : _no_type
                : _no_type
              : _no_type
            : _no_type
          : _no_type
        : _no_type
      : _no_type
    #176
    _method
      i2c
      #176
      _formal
        i
        Int
      String
      #177
      _cond
        #177
        _eq
          #177
          _object
            i
          : _no_type
          #177
          _int
            0
          : _no_type
        : _no_type
        #177
        _string
          "0"
        : _no_type
        #178
        _cond
          #178
          _eq
            #178
            _object
              i
            : _no_type
            #178
            _int
              1
            : _no_type
          : _no_type
          #178
          _string
            "1"
          : _no_type
          #179
          _cond
            #179
            _eq
              #179
              _object
                i
              : _no_type
              #179
              _int
                2
              : _no_type
            : _no_type
            #179
            _string
              "2"
            : _no_type
            #180
            _cond
              #180
              _eq
                #180
                _object
                  i
                : _no_type
                #180
                _int
                  3
                : _no_type
              : _no_type
              #180
              _string
                "3"
              : _no_type
              #181
              _cond
                #181
                _eq
                  #181
                  _object
                    i
                  : _no_type
                  #181
                  _int
                    4
                  : _no_type
                : _no_type
                #181
                _string
                  "4"
                : _no_type
                #182
                _cond
                  #182
                  _eq
                    #182
                    _object
                      i
                    : _no_type
                    #182
                    _int
                      5
                    : _no_type
                  : _no_type
                  #182
                  _string
                    "5"
                  : _no_type
                  #183
                  _cond
                    #183
                    _eq
                      #183
                      _object
                        i
                      : _no_type
                      #183
                      _int
                        6
                      : _no_type
                    : _no_type
                    #183
                    _string
                      "6"
                    : _no_type
                    #184
                    _cond
                      #184
                      _eq
                        #184
                        _object
                          i
                        : _no_type
                        #184
                        _int
                          7
                        : _no_type
                      : _no_type
                      #184
                      _string
                        "7"
                      : _no_type
                      #185
                      _cond
                        #185
                        _eq
                          #185
                          _object
                            i
                          : _no_type
                          #185
                          _int
                            8
                          : _no_type
                        : _no_type
                        #185
                        _string
                          "8"
                        : _no_type
                        #186
                        _cond
                          #186
                          _eq
                            #186
                            _object
                              i
                            : _no_type
                            #186
                            _int
                              9
                            : _no_type
                          : _no_type
                          #186
                          _string
                            "9"
                          : _no_type
                          #187
                          _block
                            #187
                            _dispatch
                              #187
                              _object
                                self
                              : _no_type
                              abort
                              (
                              )
                            : _no_type
                            #187
                            _string
                              ""
                            : _no_type
                          : _no_type
                        : _no_type
                      : _no_type
                    : _no_type
                  : _no_type
                : _no_type
              : _no_type
            : _no_type
          : _no_type
        : _no_type
      : _no_type
    #199
    _method
      a2i
      #199
      _formal
        s
        String
      Int
      #200
      _cond
        #200
        _eq
          #200
          _dispatch
            #200
            _object
              s
            : _no_type
            length
            (
            )
          : _no_type
          #200
          _int
            0
          : _no_type
        : _no_type
        #200
        _int
          0
        : _no_type
        #201
        _cond
          #201
          _eq
            #201
            _dispatch
              #201
              _object
                s
              : _no_type
              substr
              (
              #201
              _int
                0
              : _no_type
              #201
              _int
                1
              : _no_type
              )
            : _no_type
            #201
            _string
              "-"
            : _no_type
          : _no_type
          #201
          _neg
            #201
            _dispatch
              #201
              _object
                self
              : _no_type
              a2i_aux
              (
              #201
              _dispatch
                #201
                _object
                  s
                : _no_type
                substr
                (
                #201
                _int
                  1
                : _no_type
                #201
                _sub
                  #201
                  _dispatch
                    #201
                    _object
                      s
                    : _no_type
                    length
                    (
                    )
                  : _no_type
                  #201
                  _int
                    1
                  : _no_type
                : _no_type
                )
              : _no_type
              )
            : _no_type
          : _no_type
          #202
          _cond
            #202
            _eq
              #202
              _dispatch
                #202
                _object
                  s
                : _no_type
                substr
                (
                #202
                _int
                  0
                : _no_type
                #202
                _int
                  1
                : _no_type
                )
              : _no_type
              #202
              _string
                "+"
              : _no_type
            : _no_type
            #202
            _dispatch
              #202
              _object
                self
              : _no_type
              a2i_aux
              (
              #202
              _dispatch
                #202
                _object
                  s
                : _no_type
                substr
                (
                #202
                _int
                  1
                : _no_type
                #202
                _sub
                  #202
                  _dispatch
                    #202
                    _object
                      s
                    : _no_type
                    length
                    (
                    )
                  : _no_type
                  #202
                  _int
                    1
                  : _no_type
                : _no_type
                )
              : _no_type
              )
            : _no_type
            #203
            _dispatch
              #203
              _object
                self
              : _no_type
              a2i_aux
              (
              #203
              _object
                s
              : _no_type
              )
            : _no_type
          : _no_type
        : _no_type
      : _no_type
    #211
    _method
      a2i_aux
      #211
      _formal
        s
        String
      Int
      #212
      _let
        int
        Int
        #212
        _int
          0
        : _no_type
        #213
        _block
          #214
          _let
            j
            Int
            #214
            _dispatch
              #214
              _object
                s
              : _no_type
              length
              (
              )
            : _no_type
            #215
            _let
              i
              Int
              #215
              _int
                0
              : _no_type
              #216
              _loop
                #216
                _lt
                  #216
                  _object
                    i
                  : _no_type
                  #216
                  _object
                    j
                  : _no_type
                : _no_type
                #217
                _block
                  #218
                  _assign
                    int
                    #218
                    _plus
                      #218
                      _mul
                        #218
                        _object
                          int
                        : _no_type
                        #218
                        _int
                          10
                        : _no_type
                      : _no_type
                      #218
                      _dispatch
                        #218
                        _object
                          self
                        : _no_type
                        c2i
                        (
                        #218
                        _dispatch
                          #218
                          _object
                            s
                          : _no_type
                          substr
                          (
                          #218
                          _object
                            i
                          : _no_type
                          #218
                          _int
                            1
                          : _no_type
                          )
                        : _no_type
                        )
                      : _no_type
                    : _no_type
                  : _no_type
                  #219
                  _assign
                    i
                    #219
                    _plus
                      #219
                      _object
                        i
                      : _no_type
                      #219
                      _int
                        1
                      : _no_type
                    : _no_type
                  : _no_type
                : _no_type
              : _no_type
            : _no_type
          : _no_type
          #224
          _object
            int
          : _no_type
        : _no_type
      : _no_type
    #232
    _method
      i2a
      #232
      _formal
        i
        Int
      String
      #233
      _cond
        #233
        _eq
          #233
          _object
            i
          : _no_type
          #233
          _int
            0
          : _no_type
        : _no_type
        #233
        _string
          "0"
        : _no_type
        #234
        _cond
          #234
          _lt
            #234
            _int
              0
            : _no_type
            #234
            _object
              i
            : _no_type
          : _no_type
          #234
          _dispatch
            #234
            _object
              self
            : _no_type
            i2a_aux
            (
            #234
            _object
              i
            : _no_type
            )
          : _no_type
          #235
          _dispatch
            #235
            _string
              "-"
            : _no_type
            concat
            (
            #235
            _dispatch
              #235
              _object
                self
              : _no_type
              i2a_aux
              (
              #235
              _mul
                #235
                _object
                  i
                : _no_type
                #235
                _neg
                  #235
                  _int
                    1
                  : _no_type
                : _no_type
              : _no_type
              )
            : _no_type
            )
          : _no_type
        : _no_type
      : _no_type
    #241
    _method
      i2a_aux
      #241
      _formal
        i
        Int
      String
      #242
      _cond
        #242
        _eq
          #242
          _object
            i
          : _no_type
          #242
          _int
            0
          : _no_type
        : _no_type
        #242
        _string
          ""
        : _no_type
        #243
        _let
          next
          Int
          #243
          _divide
            #243
            _object
              i
            : _no_type
            #243
            _int
              10
            : _no_type
          : _no_type
          #244
          _dispatch
            #244
            _dispatch
              #244
              _object
                self
              : _no_type
              i2a_aux
              (
              #244
              _object
                next
              : _no_type
              )
            : _no_type
            concat
            (
            #244
            _dispatch
              #244
              _object
                self
              : _no_type
              i2c
              (
              #244
              _sub
                #244
                _object
                  i
                : _no_type
                #244
                _mul
                  #244
                  _object
                    next
                  : _no_type
                  #244
                  _int
                    10
                  : _no_type
                : _no_type
              : _no_type
              )
            : _no_type
            )
          : _no_type
        : _no_type
      : _no_type
    )
  #251
  _class
    Main
    IO
    "good1.cl"
    (
    #253
    _attr
      char
      String
      #253
      _no_expr
      : _no_type
    #254
    _attr
      avar
      A
      #254
      _no_expr
      : _no_type
    #255
    _attr
      a_var
      A
      #255
      _no_expr
      : _no_type
    #256
    _attr
      flag
      Bool
      #256
      _bool
        1
      : _no_type
    #259
    _method
      menu
      String
      #260
      _block
        #261
        _dispatch
          #261
          _object
            self
          : _no_type
          out_string
          (
          #261
          _string
            "\n\tTo add a number to "
          : _no_type
          )
        : _no_type
        #262
        _dispatch
          #262
          _object
            self
          : _no_type
          print
          (
          #262
          _object
            avar
          : _no_type
          )
        : _no_type
        #263
        _dispatch
          #263
          _object
            self
          : _no_type
          out_string
          (
          #263
          _string
            "...enter a:\n"
          : _no_type
          )
        : _no_type
        #264
        _dispatch
          #264
          _object
            self
          : _no_type
          out_string
          (
          #264
          _string
            "\tTo negate "
          : _no_type
          )
        : _no_type
        #265
        _dispatch
          #265
          _object
            self
          : _no_type
          print
          (
          #265
          _object
            avar
          : _no_type
          )
        : _no_type
        #266
        _dispatch
          #266
          _object
            self
          : _no_type
          out_string
          (
          #266
          _string
            "...enter b:\n"
          : _no_type
          )
        : _no_type
        #267
        _dispatch
          #267
          _object
            self
          : _no_type
          out_string
          (
          #267
          _string
            "\tTo find the difference between "
          : _no_type
          )
        : _no_type
        #268
        _dispatch
          #268
          _object
            self
          : _no_type
          print
          (
          #268
          _object
            avar
          : _no_type
          )
        : _no_type
        #269
        _dispatch
          #269
          _object
            self
          : _no_type
          out_string
          (
          #269
          _string
            "and another number...enter c:\n"
          : _no_type
          )
        : _no_type
        #270
        _dispatch
          #270
          _object
            self
          : _no_type
          out_string
          (
          #270
          _string
            "\tTo find the factorial of "
          : _no_type
          )
        : _no_type
        #271
        _dispatch
          #271
          _object
            self
          : _no_type
          print
          (
          #271
          _object
            avar
          : _no_type
          )
        : _no_type
        #272
        _dispatch
          #272
          _object
            self
          : _no_type
          out_string
          (
          #272
          _string
            "...enter d:\n"
          : _no_type
          )
        : _no_type
        #273
        _dispatch
          #273
          _object
            self
          : _no_type
          out_string
          (
          #273
          _string
            "\tTo square "
          : _no_type
          )
        : _no_type
        #274
        _dispatch
          #274
          _object
            self
          : _no_type
          print
          (
          #274
          _object
            avar
          : _no_type
          )
        : _no_type
        #275
        _dispatch
          #275
          _object
            self
          : _no_type
          out_string
          (
          #275
          _string
            "...enter e:\n"
          : _no_type
          )
        : _no_type
        #276
        _dispatch
          #276
          _object
            self
          : _no_type
          out_string
          (
          #276
          _string
            "\tTo cube "
          : _no_type
          )
        : _no_type
        #277
        _dispatch
          #277
          _object
            self
          : _no_type
          print
          (
          #277
          _object
            avar
          : _no_type
          )
        : _no_type
        #278
        _dispatch
          #278
          _object
            self
          : _no_type
          out_string
          (
          #278
          _string
            "...enter f:\n"
          : _no_type
          )
        : _no_type
        #279
        _dispatch
          #279
          _object
            self
          : _no_type
          out_string
          (
          #279
          _string
            "\tTo find out if "
          : _no_type
          )
        : _no_type
        #280
        _dispatch
          #280
          _object
            self
          : _no_type
          print
          (
          #280
          _object
            avar
          : _no_type
          )
        : _no_type
        #281
        _dispatch
          #281
          _object
            self
          : _no_type
          out_string
          (
          #281
          _string
            "is a multiple of 3...enter g:\n"
          : _no_type
          )
        : _no_type
        #282
        _dispatch
          #282
          _object
            self
          : _no_type
          out_string
          (
          #282
          _string
            "\tTo divide "
          : _no_type
          )
        : _no_type
        #283
        _dispatch
          #283
          _object
            self
          : _no_type
          print
          (
          #283
          _object
            avar
          : _no_type
          )
        : _no_type
        #284
        _dispatch
          #284
          _object
            self
          : _no_type
          out_string
          (
          #284
          _string
            "by 8...enter h:\n"
          : _no_type
          )
        : _no_type
        #285
        _dispatch
          #285
          _object
            self
          : _no_type
          out_string
          (
          #285
          _string
            "\tTo get a new number...enter j:\n"
          : _no_type
          )
        : _no_type
        #286
        _dispatch
          #286
          _object
            self
          : _no_type
          out_string
          (
          #286
          _string
            "\tTo quit...enter q:\n\n"
          : _no_type
          )
        : _no_type
        #287
        _dispatch
          #287
          _object
            self
          : _no_type
          in_string
          (
          )
        : _no_type
      : _no_type
    #291
    _method
      prompt
      String
      #292
      _block
        #293
        _dispatch
          #293
          _object
            self
          : _no_type
          out_string
          (
          #293
          _string
            "\n"
          : _no_type
          )
        : _no_type
        #294
        _dispatch
          #294
          _object
            self
          : _no_type
          out_string
          (
          #294
          _string
            "Please enter a number...  "
          : _no_type
          )
        : _no_type
        #295
        _dispatch
          #295
          _object
            self
          : _no_type
          in_string
          (
          )
        : _no_type
      : _no_type
    #299
    _method
      get_int
      Int
      #300
      _block
        #301
        _let
          z
          A2I
          #301
          _new
            A2I
          : _no_type
          #302
          _let
            s
            String
            #302
            _dispatch
              #302
              _object
                self
              : _no_type
              prompt
              (
              )
            : _no_type
            #303
            _dispatch
              #303
              _object
                z
              : _no_type
              a2i
              (
              #303
              _object
                s
              : _no_type
              )
            : _no_type
          : _no_type
        : _no_type
      : _no_type
    #309
    _method
      is_even
      #309
      _formal
        num
        Int
      Bool
      #310
      _let
        x
        Int
        #310
        _object
          num
        : _no_type
        #311
        _cond
          #311
          _lt
            #311
            _object
              x
            : _no_type
            #311
            _int
              0
            : _no_type
          : _no_type
          #311
          _dispatch
            #311
            _object
              self
            : _no_type
            is_even
            (
            #311
            _neg
              #311
              _object
                x
              : _no_type
            : _no_type
            )
          : _no_type
          #312
          _cond
            #312
            _eq
              #312
              _int
                0
              : _no_type
              #312
              _object
                x
              : _no_type
            : _no_type
            #312
            _bool
              1
            : _no_type
            #313
            _cond
              #313
              _eq
                #313
                _int
                  1
                : _no_type
                #313
                _object
                  x
                : _no_type
              : _no_type
              #313
              _bool
                0
              : _no_type
              #314
              _dispatch
                #314
                _object
                  self
                : _no_type
                is_even
                (
                #314
                _sub
                  #314
                  _object
                    x
                  : _no_type
                  #314
                  _int
                    2
                  : _no_type
                : _no_type
                )
              : _no_type
            : _no_type
          : _no_type
        : _no_type
      : _no_type
    #319
    _method
      class_type
      #319
      _formal
        var
        A
      SELF_TYPE
      #320
      _typcase
        #320
        _object
          var
        : _no_type
        #321
        _branch
          a
          A
          #321
          _dispatch
            #321
            _object
              self
            : _no_type
            out_string
            (
            #321
            _string
              "Class type is now A\n"
            : _no_type
            )
          : _no_type
        #322
        _branch
          b
          B
          #322
          _dispatch
            #322
            _object
              self
            : _no_type
            out_string
            (
            #322
            _string
              "Class type is now B\n"
            : _no_type
            )
          : _no_type
        #323
        _branch
          c
          C
          #323
          _dispatch
            #323
            _object
              self
            : _no_type
            out_string
            (
            #323
            _string
              "Class type is now C\n"
            : _no_type
            )
          : _no_type
        #324
        _branch
          d
          D
          #324
          _dispatch
            #324
            _object
              self
            : _no_type
            out_string
            (
            #324
            _string
              "Class type is now D\n"
            : _no_type
            )
          : _no_type
        #325
        _branch
          e
          E
          #325
          _dispatch
            #325
            _object
              self
            : _no_type
            out_string
            (
            #325
            _string
              "Class type is now E\n"
            : _no_type
            )
          : _no_type
        #326
        _branch
          o
          Object
          #326
          _dispatch
            #326
            _object
              self
            : _no_type
            out_string
            (
            #326
            _string
              "Oooops\n"
            : _no_type
            )
          : _no_type
      : _no_type
    #330
    _method
      print
      #330
      _formal
        var
        A
      SELF_TYPE
      #331
      _let
        z
        A2I
        #331
        _new
          A2I
        : _no_type
        #332
        _block
          #333
          _dispatch
            #333
            _object
              self
            : _no_type
            out_string
            (
            #333
            _dispatch
              #333
              _object
                z
              : _no_type
              i2a
              (
              #333
              _dispatch
                #333
                _object
                  var
                : _no_type
                value
                (
                )
              : _no_type
              )
            : _no_type
            )
          : _no_type
          #334
          _dispatch
            #334
            _object
              self
            : _no_type
            out_string
            (
            #334
            _string
              " "
            : _no_type
            )
          : _no_type
        : _no_type
      : _no_type
    #339
    _method
      main
      Object
      #340
      _block
        #341
        _assign
          avar
          #341
          _new
            A
          : _no_type
        : _no_type
        #342
        _loop
          #342
          _object
            flag
          : _no_type
          #343
          _block
            #345
            _dispatch
              #345
              _object
                self
              : _no_type
              out_string
              (
              #345
              _string
                "number "
              : _no_type
              )
            : _no_type
            #346
            _dispatch
              #346
              _object
                self
              : _no_type
              print
              (
              #346
              _object
                avar
              : _no_type
              )
            : _no_type
            #347
            _cond
              #347
              _dispatch
                #347
                _object
                  self
                : _no_type
                is_even
                (
                #347
                _dispatch
                  #347
                  _object
                    avar
                  : _no_type
                  value
                  (
                  )
                : _no_type
                )
              : _no_type
              #348
              _dispatch
                #348
                _object
                  self
                : _no_type
                out_string
                (
                #348
                _string
                  "is even!\n"
                : _no_type
                )
              : _no_type
              #350
              _dispatch
                #350
                _object
                  self
                : _no_type
                out_string
                (
                #350
                _string
                  "is odd!\n"
                : _no_type
                )
              : _no_type
            : _no_type
            #353
            _dispatch
              #353
              _object
                self
              : _no_type
              class_type
              (
              #353
              _object
                avar
              : _no_type
              )
            : _no_type
            #354
            _assign
              char
              #354
              _dispatch
                #354
                _object
                  self
                : _no_type
                menu
                (
                )
              : _no_type
            : _no_type
            #355
            _cond
              #355
              _eq
                #355
                _object
                  char
                : _no_type
                #355
                _string
                  "a"
                : _no_type
              : _no_type
              #356
              _block
                #357
                _assign
                  a_var
                  #357
                  _dispatch
                    #357
                    _new
                      A
                    : _no_type
                    set_var
                    (
                    #357
                    _dispatch
                      #357
                      _object
                        self
                      : _no_type
                      get_int
                      (
                      )
                    : _no_type
                    )
                  : _no_type
                : _no_type
                #358
                _assign
                  avar
                  #358
                  _dispatch
                    #358
                    _new
                      B
                    : _no_type
                    method2
                    (
                    #358
                    _dispatch
                      #358
                      _object
                        avar
                      : _no_type
                      value
                      (
                      )
                    : _no_type
                    #358
                    _dispatch
                      #358
                      _object
                        a_var
                      : _no_type
                      value
                      (
                      )
                    : _no_type
                    )
                  : _no_type
                : _no_type
              : _no_type
              #360
              _cond
                #360
                _eq
                  #360
                  _object
                    char
                  : _no_type
                  #360
                  _string
                    "b"
                  : _no_type
                : _no_type
                #361
                _typcase
                  #361
                  _object
                    avar
                  : _no_type
                  #362
                  _branch
                    c
                    C
                    #362
                    _assign
                      avar
                      #362
                      _dispatch
                        #362
                        _object
                          c
                        : _no_type
                        method6
                        (
                        #362
                        _dispatch
                          #362
                          _object
                            c
                          : _no_type
                          value
                          (
                          )
                        : _no_type
                        )
                      : _no_type
                    : _no_type
                  #363
                  _branch
                    a
                    A
                    #363
                    _assign
                      avar
                      #363
                      _dispatch
                        #363
                        _object
                          a
                        : _no_type
                        method3
                        (
                        #363
                        _dispatch
                          #363
                          _object
                            a
                          : _no_type
                          value
                          (
                          )
                        : _no_type
                        )
                      : _no_type
                    : _no_type
                  #364
                  _branch
                    o
                    Object
                    #364
                    _block
                      #365
                      _dispatch
                        #365
                        _object
                          self
                        : _no_type
                        out_string
                        (
                        #365
                        _string
                          "Oooops\n"
                        : _no_type
                        )
                      : _no_type
                      #366
                      _dispatch
                        #366
                        _object
                          self
                        : _no_type
                        abort
                        (
                        )
                      : _no_type
                      #366
                      _int
                        0
                      : _no_type
                    : _no_type
                : _no_type
                #369
                _cond
                  #369
                  _eq
                    #369
                    _object
                      char
                    : _no_type
                    #369
                    _string
                      "c"
                    : _no_type
                  : _no_type
                  #370
                  _block
                    #371
                    _assign
                      a_var
                      #371
                      _dispatch
                        #371
                        _new
                          A
                        : _no_type
                        set_var
                        (
                        #371
                        _dispatch
                          #371
                          _object
                            self
                          : _no_type
                          get_int
                          (
                          )
                        : _no_type
                        )
                      : _no_type
                    : _no_type
                    #372
                    _assign
                      avar
                      #372
                      _dispatch
                        #372
                        _new
                          D
                        : _no_type
                        method4
                        (
                        #372
                        _dispatch
                          #372
                          _object
                            avar
                          : _no_type
                          value
                          (
                          )
                        : _no_type
                        #372
                        _dispatch
                          #372
                          _object
                            a_var
                          : _no_type
                          value
                          (
                          )
                        : _no_type
                        )
                      : _no_type
                    : _no_type
                  : _no_type
                  #374
                  _cond
                    #374
                    _eq
                      #374
                      _object
                        char
                      : _no_type
                      #374
                      _string
                        "d"
                      : _no_type
                    : _no_type
                    #374
                    _assign
                      avar
                      #374
                      _static_dispatch
                        #374
                        _new
                          C
                        : _no_type
                        A
                        method5
                        (
                        #374
                        _dispatch
                          #374
                          _object
                            avar
                          : _no_type
                          value
                          (
                          )
                        : _no_type
                        )
                      : _no_type
                    : _no_type
                    #376
                    _cond
                      #376
                      _eq
                        #376
                        _object
                          char
                        : _no_type
                        #376
                        _string
                          "e"
                        : _no_type
                      : _no_type
                      #376
                      _assign
                        avar
                        #376
                        _static_dispatch
                          #376
                          _new
                            C
                          : _no_type
                          B
                          method5
                          (
                          #376
                          _dispatch
                            #376
                            _object
                              avar
                            : _no_type
                            value
                            (
                            )
                          : _no_type
                          )
                        : _no_type
                      : _no_type
                      #378
                      _cond
                        #378
                        _eq
                          #378
                          _object
                            char
                          : _no_type
                          #378
                          _string
                            "f"
                          : _no_type
                        : _no_type
                        #378
                        _assign
                          avar
                          #378
                          _static_dispatch
                            #378
                            _new
                              C
                            : _no_type
                            C
                            method5
                            (
                            #378
                            _dispatch
                              #378
                              _object
                                avar
                              : _no_type
                              value
                              (
                              )
                            : _no_type
                            )
                          : _no_type
                        : _no_type
                        #380
                        _cond
                          #380
                          _eq
                            #380
                            _object
                              char
                            : _no_type
                            #380
                            _string
                              "g"
                            : _no_type
                          : _no_type
                          #381
                          _cond
                            #381
                            _dispatch
                              #381
                              _new
                                D
                              : _no_type
                              method7
                              (
                              #381
                              _dispatch
                                #381
                                _object
                                  avar
                                : _no_type
                                value
                                (
                                )
                              : _no_type
                              )
                            : _no_type
                            #383
                            _block
                              #384
                              _dispatch
                                #384
                                _object
                                  self
                                : _no_type
                                out_string
                                (
                                #384
                                _string
                                  "number "
                                : _no_type
                                )
                              : _no_type
                              #385
                              _dispatch
                                #385
                                _object
                                  self
                                : _no_type
                                print
                                (
                                #385
                                _object
                                  avar
                                : _no_type
                                )
                              : _no_type
                              #386
                              _dispatch
                                #386
                                _object
                                  self
                                : _no_type
                                out_string
                                (
                                #386
                                _string
                                  "is divisible by 3.\n"
                                : _no_type
                                )
                              : _no_type
                            : _no_type
                            #389
                            _block
                              #390
                              _dispatch
                                #390
                                _object
                                  self
                                : _no_type
                                out_string
                                (
                                #390
                                _string
                                  "number "
                                : _no_type
                                )
                              : _no_type
                              #391
                              _dispatch
                                #391
                                _object
                                  self
                                : _no_type
                                print
                                (
                                #391
                                _object
                                  avar
                                : _no_type
                                )
                              : _no_type
                              #392
                              _dispatch
                                #392
                                _object
                                  self
                                : _no_type
                                out_string
                                (
                                #392
                                _string
                                  "is not divisible by 3.\n"
                                : _no_type
                                )
                              : _no_type
                            : _no_type
                          : _no_type
                          #395
                          _cond
                            #395
                            _eq
                              #395
                              _object
                                char
                              : _no_type
                              #395
                              _string
                                "h"
                              : _no_type
                            : _no_type
                            #396
                            _let
                              x
                              A
                              #396
                              _no_expr
                              : _no_type
                              #397
                              _block
                                #398
                                _assign
                                  x
                                  #398
                                  _dispatch
                                    #398
                                    _new
                                      E
                                    : _no_type
                                    method6
                                    (
                                    #398
                                    _dispatch
                                      #398
                                      _object
                                        avar
                                      : _no_type
                                      value
                                      (
                                      )
                                    : _no_type
                                    )
                                  : _no_type
                                : _no_type
                                #399
                                _let
                                  r
                                  Int
                                  #399
                                  _sub
                                    #399
                                    _dispatch
                                      #399
                                      _object
                                        avar
                                      : _no_type
                                      value
                                      (
                                      )
                                    : _no_type
                                    #399
                                    _mul
                                      #399
                                      _dispatch
                                        #399
                                        _object
                                          x
                                        : _no_type
                                        value
                                        (
                                        )
                                      : _no_type
                                      #399
                                      _int
                                        8
                                      : _no_type
                                    : _no_type
                                  : _no_type
                                  #400
                                  _block
                                    #401
                                    _dispatch
                                      #401
                                      _object
                                        self
                                      : _no_type
                                      out_string
                                      (
                                      #401
                                      _string
                                        "number "
                                      : _no_type
                                      )
                                    : _no_type
                                    #402
                                    _dispatch
                                      #402
                                      _object
                                        self
                                      : _no_type
                                      print
                                      (
                                      #402
                                      _object
                                        avar
                                      : _no_type
                                      )
                                    : _no_type
                                    #403
                                    _dispatch
                                      #403
                                      _object
                                        self
                                      : _no_type
                                      out_string
                                      (
                                      #403
                                      _string
                                        "is equal to "
                                      : _no_type
                                      )
                                    : _no_type
                                    #404
                                    _dispatch
                                      #404
                                      _object
                                        self
                                      : _no_type
                                      print
                                      (
                                      #404
                                      _object
                                        x
                                      : _no_type
                                      )
                                    : _no_type
                                    #405
                                    _dispatch
                                      #405
                                      _object
                                        self
                                      : _no_type
                                      out_string
                                      (
                                      #405
                                      _string
                                        "times 8 with a remainder of "
                                      : _no_type
                                      )
                                    : _no_type
                                    #406
                                    _let
                                      a
                                      A2I
                                      #406
                                      _new
                                        A2I
                                      : _no_type
                                      #407
                                      _block
                                        #408
                                        _dispatch
                                          #408
                                          _object
                                            self
                                          : _no_type
                                          out_string
                                          (
                                          #408
                                          _dispatch
                                            #408
                                            _object
                                              a
                                            : _no_type
                                            i2a
                                            (
                                            #408
                                            _object
                                              r
                                            : _no_type
                                            )
                                          : _no_type
                                          )
                                        : _no_type
                                        #409
                                        _dispatch
                                          #409
                                          _object
                                            self
                                          : _no_type
                                          out_string
                                          (
                                          #409
                                          _string
                                            "\n"
                                          : _no_type
                                          )
                                        : _no_type
                                      : _no_type
                                    : _no_type
                                  : _no_type
                                : _no_type
                                #414
                                _assign
                                  avar
                                  #414
                                  _object
                                    x
                                  : _no_type
                                : _no_type
                              : _no_type
                            : _no_type
                            #418
                            _cond
                              #418
                              _eq
                                #418
                                _object
                                  char
                                : _no_type
                                #418
                                _string
                                  "j"
                                : _no_type
                              : _no_type
                              #418
                              _assign
                                avar
                                #418
                                _new
                                  A
                                : _no_type
                              : _no_type
                              #420
                              _cond
                                #420
                                _eq
                                  #420
                                  _object
                                    char
                                  : _no_type
                                  #420
                                  _string
                                    "q"
                                  : _no_type
                                : _no_type
                                #420
                                _assign
                                  flag
                                  #420
                                  _bool
                                    0
                                  : _no_type
                                : _no_type
                                #422
                                _assign
                                  avar
                                  #422
                                  _dispatch
                                    #422
                                    _new
                                      A
                                    : _no_type
                                    method1
                                    (
                                    #422
                                    _dispatch
                                      #422
                                      _object
                                        avar
                                      : _no_type
                                      value
                                      (
                                      )
                                    : _no_type
                                    )
                                  : _no_type
                                : _no_type
                              : _no_type
                            : _no_type
                          : _no_type
                        : _no_type
                      : _no_type
                    : _no_type
                  : _no_type
                : _no_type
              : _no_type
            : _no_type
          : _no_type
        : _no_type
      : _no_type
    )
